// Generated by LiveScript 1.5.0
(function(){
  'use strict';
  var util, js;
  util = require('util');
  js = require('js-extensions');
  module.exports = function(){
    var this$ = this;
    this.register_special_command({
      name: 'admins',
      description: 'Display a list of my administrators',
      admin_only: false,
      fn: function(event, input_data, output_data){
        var message, i$, ref$, len$, admin, nick, host;
        if (in$('?', input_data.flags)) {
          message = 'Display a list of my administrators';
        } else {
          message = [];
          for (i$ = 0, len$ = (ref$ = this$.botOptions.admins).length; i$ < len$; ++i$) {
            admin = ref$[i$];
            nick = admin.nick || '(null)';
            host = admin.host || '(null)';
            message.push("nick: " + nick + " • host: " + host);
          }
        }
        return this$.send('notice', event.person.nick, message);
      }
    });
    this.register_special_command({
      name: 'commands',
      description: 'Display a list of special commands I support',
      admin_only: false,
      fn: function(event, input_data, output_data){
        var message, name, ref$, command, permission, own$ = {}.hasOwnProperty;
        if (in$('?', input_data.flags)) {
          message = ['Syntax: commands[/v] • Display a list of special commands I support', '--- This command supports the following flags ---', 'v • verbose: also lists the description and permission level for each command'];
        } else if (in$('v', input_data.flags)) {
          message = [];
          for (name in ref$ = this$.special_commands) if (own$.call(ref$, name)) {
            command = ref$[name];
            permission = command.admin_only ? ' • admin only' : '';
            message.push(command.name + " • " + command.description + permission);
          }
        } else {
          message = Object.keys(this$.special_commands);
          message = message.join(' • ');
        }
        return this$.send('notice', event.person.nick, message);
      }
    });
    this.register_special_command({
      name: 'topic',
      description: 'Display the topic for the current channel; only works in channels',
      admin_only: false,
      fn: function(event, input_data, output_data){
        var message;
        if (in$('?', input_data.flags)) {
          message = 'Display the channel topic for the current channel; only works in channels';
          this$.send('notice', event.person.nick, message);
        } else {
          if (event.recipient[0] !== '#') {
            return;
          }
          return this$.irc.topic(event.recipient, function(channel, message){
            return this$.send(output_data.method, output_data.recipient, "Topic for " + channel + " is « " + message + " »");
          });
        }
      }
    });
    this.register_special_command({
      name: 'info',
      description: 'Display information about a factoid',
      admin_only: false,
      fn: function(event, input_data, output_data){
        var message, factoid_name, factoid_content, is_alias, factoid_original_name, factoid_original_content, aliases;
        if (in$('?', input_data.flags)) {
          message = "info <factoid-name> • Display information about a factoid";
        } else if (!input_data.args.trim()) {
          message = "Sorry, I didn't see a factoid name there!";
        } else if (!input_data.args.trim() in this$.factoids) {
          message = "Sorry, I couldn't find a factoid with the name « " + input_data.args + " »";
        } else {
          message = [];
          factoid_name = input_data.args.trim();
          factoid_content = this$.factoids[factoid_name];
          is_alias = /^alias:/.test(factoid_content);
          factoid_original_name = is_alias ? factoid_content.match(/^alias:(.*)/)[1] : factoid_name;
          factoid_original_content = this$.factoids[factoid_original_name];
          aliases = this$.factoid_get_aliases(factoid_original_name);
          if (is_alias) {
            message.push("« " + factoid_name + " » is an alias for « " + factoid_original_name + " »");
          } else {
            message.push("« " + factoid_name + " » is not an alias");
          }
          if (aliases) {
            message.push("The following names are aliases for « " + factoid_original_name + " »: " + aliases.join(' • '));
          } else {
            message.push("There are no aliases for « " + factoid_original_name + " »");
          }
          message.push("« " + factoid_original_name + " » is « " + factoid_original_content + " »");
        }
        return this$.send('notice', event.person.nick, message);
      }
    });
    return this.register_special_command({
      name: 'search',
      description: 'Search the factoids store',
      admin_only: false,
      fn: function(event, input_data, output_data){
        var message, query, results, max_results, flag_n, flag_c, flag_o, flag_a, factoid_name, ref$, factoid_content, is_alias, num_results, showing, own$ = {}.hasOwnProperty;
        if (in$('?', input_data.flags)) {
          message = ['Syntax: search[/oanc] • Search the factoids store', '--- This command supports the following flags ---', 'o • original: only search \'original\' factoids; that is, factoids that are not aliases', 'a • aliases: only search aliases', 'n • names: only search factoid names', 'c • content: only search factoid content', 'Note: flags \'o\' and \'a\' are mutually exclusive', 'Note: flags \'n\' and \'c\' are mutually exclusive'];
        } else if (!input_data.args) {
          message = 'Sorry, I didn\'t see a search term there!';
        } else {
          query = new RegExp(js.re_escape(input_data.args), 'i');
          results = [];
          max_results = 20;
          flag_n = in$('n', input_data.flags);
          flag_c = in$('c', input_data.flags);
          flag_o = in$('o', input_data.flags);
          flag_a = in$('a', input_data.flags);
          for (factoid_name in ref$ = this$.factoids) if (own$.call(ref$, factoid_name)) {
            factoid_content = ref$[factoid_name];
            is_alias = /^alias:/.test(factoid_content);
            if (flag_n && !flag_c) {
              if (query.test(factoid_name)) {
                if ((flag_a && !flag_o && is_alias) || (flag_o && !flag_a && !is_alias) || (!flag_a && !flag_o)) {
                  results.push(factoid_name);
                }
              }
            } else if (flag_c && !flag_n) {
              if (query.test(factoid_content)) {
                if ((flag_a && !flag_o && is_alias) || (flag_o && !flag_a && !is_alias) || (!flag_a && !flag_o)) {
                  results.push(factoid_name);
                }
              }
            } else {
              if (query.test(factoid_name) || query.test(factoid_content)) {
                if ((flag_a && !flag_o && is_alias) || (flag_o && !flag_a && !is_alias) || (!flag_a && !flag_o)) {
                  results.push(factoid_name);
                }
              }
            }
          }
          if (results.length) {
            num_results = results.length;
            showing = num_results > max_results ? " (showing " + max_results + ")" : '';
            results = results.slice(0, max_results);
            message = "Found " + num_results + " results for query « " + input_data.args + " »" + showing + ": " + results.join(' • ');
          } else {
            message = "Sorry, I couldn't find any results for query « " + input_data.args + " »";
          }
        }
        return this$.send('notice', event.person.nick, message);
      }
    });
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
